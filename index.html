<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blok Fruits Game</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container"></div>
        <div id="loading-screen">
            <div class="loading-text">Loading...</div>
            <div class="progress-bar">
                <div class="progress"></div>
            </div>
        </div>
    </div>

    <!-- Using inline THREE.js to ensure it's available -->
    <script>
        // Define basic THREE object to allow the game to start
        window.THREE = {
            REVISION: 'CustomMock-1.0.0',
            LoadingManager: function() {
                this.onProgress = function() {};
                this.onLoad = function() {};
                this.onError = function() {};
                return this;
            },
            TextureLoader: function() {
                this.load = function(path, onLoad) {
                    console.log("Loading texture:", path);
                    // Create a simple texture object
                    const texture = {
                        name: path.split('/').pop(),
                        image: { width: 256, height: 256 },
                        dispose: function() {}
                    };
                    // Call the success callback
                    if (onLoad) setTimeout(() => onLoad(texture), 100);
                    return texture;
                };
                return this;
            },
            Color: function(hex) {
                this.hex = hex;
                this.r = 1; 
                this.g = 1;
                this.b = 1;
                this.set = function(hex) { 
                    this.hex = hex; 
                    return this; 
                };
                return this;
            },
            Scene: function() {
                this.background = null;
                this.children = [];
                this.add = function(obj) {
                    console.log("Added to scene:", obj);
                    if (obj) this.children.push(obj);
                };
                this.remove = function(obj) {
                    const index = this.children.indexOf(obj);
                    if (index !== -1) this.children.splice(index, 1);
                };
                this.traverse = function(callback) {
                    if (typeof callback === 'function') {
                        this.children.forEach(callback);
                    }
                };
                return this;
            },
            PerspectiveCamera: function(fov, aspect, near, far) {
                this.fov = fov || 75;
                this.aspect = aspect || 1;
                this.near = near || 0.1;
                this.far = far || 1000;
                this.position = {
                    x: 0, y: 0, z: 0, 
                    set: function(x, y, z) {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                    }
                };
                this.lookAt = function(x, y, z) {
                    console.log("Camera looking at:", x, y, z);
                };
                this.updateProjectionMatrix = function() {};
                return this;
            },
            WebGLRenderer: function(params) {
                this.domElement = document.createElement('canvas');
                this.domElement.width = window.innerWidth;
                this.domElement.height = window.innerHeight;
                this.domElement.clientWidth = window.innerWidth;
                this.domElement.clientHeight = window.innerHeight;
                this.setSize = function(width, height) {
                    this.domElement.width = width;
                    this.domElement.height = height;
                    this.domElement.clientWidth = width;
                    this.domElement.clientHeight = height;
                };
                this.setPixelRatio = function() {};
                this.render = function(scene, camera) {
                    // console.log("Rendering scene with", scene.children.length, "objects");
                };
                this.shadowMap = {
                    enabled: false,
                    type: null
                };
                this.dispose = function() {};
                return this;
            },
            AmbientLight: function(color, intensity) {
                this.color = new THREE.Color(color);
                this.intensity = intensity || 1;
                return this;
            },
            DirectionalLight: function(color, intensity) {
                this.color = new THREE.Color(color);
                this.intensity = intensity || 1;
                this.position = {
                    x: 0, y: 0, z: 0,
                    set: function(x, y, z) {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                    }
                };
                this.castShadow = false;
                this.shadow = {
                    mapSize: {width: 0, height: 0},
                    camera: {
                        near: 0, far: 0, 
                        left: 0, right: 0, 
                        top: 0, bottom: 0
                    }
                };
                return this;
            },
            PlaneGeometry: function(width, height, widthSegments, heightSegments) {
                this.parameters = {
                    width: width || 1,
                    height: height || 1,
                    widthSegments: widthSegments || 1,
                    heightSegments: heightSegments || 1
                };
                this.dispose = function() {};
                return this;
            },
            CylinderGeometry: function(topRadius, bottomRadius, height, radialSegments, heightSegments, openEnded) {
                this.parameters = {
                    topRadius: topRadius || 1,
                    bottomRadius: bottomRadius || 1,
                    height: height || 1,
                    radialSegments: radialSegments || 8,
                    heightSegments: heightSegments || 1,
                    openEnded: openEnded || false
                };
                this.dispose = function() {};
                return this;
            },
            SphereGeometry: function(radius, widthSegments, heightSegments) {
                this.parameters = {
                    radius: radius || 1,
                    widthSegments: widthSegments || 8,
                    heightSegments: heightSegments || 6
                };
                this.dispose = function() {};
                return this;
            },
            RingGeometry: function(innerRadius, outerRadius, thetaSegments) {
                this.parameters = {
                    innerRadius: innerRadius || 0.5,
                    outerRadius: outerRadius || 1,
                    thetaSegments: thetaSegments || 8
                };
                this.dispose = function() {};
                return this;
            },
            MeshStandardMaterial: function(params) {
                this.color = params && params.color ? new THREE.Color(params.color) : new THREE.Color(0xffffff);
                this.metalness = params && params.metalness !== undefined ? params.metalness : 0.1;
                this.roughness = params && params.roughness !== undefined ? params.roughness : 0.5;
                this.transparent = params && params.transparent !== undefined ? params.transparent : false;
                this.opacity = params && params.opacity !== undefined ? params.opacity : 1.0;
                this.side = params && params.side !== undefined ? params.side : 'frontside';
                this.dispose = function() {};
                return this;
            },
            MeshBasicMaterial: function(params) {
                this.color = params && params.color ? new THREE.Color(params.color) : new THREE.Color(0xffffff);
                this.transparent = params && params.transparent !== undefined ? params.transparent : false;
                this.opacity = params && params.opacity !== undefined ? params.opacity : 1.0;
                this.side = params && params.side !== undefined ? params.side : 'frontside';
                this.dispose = function() {};
                return this;
            },
            Mesh: function(geometry, material) {
                this.geometry = geometry;
                this.material = material;
                this.rotation = {x: 0, y: 0, z: 0};
                this.position = {x: 0, y: 0, z: 0};
                this.scale = {
                    x: 1, y: 1, z: 1,
                    set: function(x, y, z) {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                    }
                };
                this.userData = {};
                this.children = [];
                this.parent = null;
                this.add = function(obj) {
                    if (obj) {
                        this.children.push(obj);
                        obj.parent = this;
                    }
                };
                this.remove = function(obj) {
                    const index = this.children.indexOf(obj);
                    if (index !== -1) {
                        this.children.splice(index, 1);
                        obj.parent = null;
                    }
                };
                return this;
            },
            Vector2: function(x, y) {
                this.x = x || 0;
                this.y = y || 0;
                return this;
            },
            Vector3: function(x, y, z) {
                this.x = x || 0; 
                this.y = y || 0; 
                this.z = z || 0;
                return this;
            },
            Raycaster: function() {
                this.setFromCamera = function(coords, camera) {
                    // Mock implementation
                };
                this.intersectObjects = function(objects, recursive) {
                    // Return empty array as default to prevent errors
                    console.log("Raycasting against", objects ? objects.length : 0, "objects");
                    return [];
                };
                return this;
            },
            DoubleSide: 'doubleside',
            FrontSide: 'frontside',
            BackSide: 'backside',
            PCFSoftShadowMap: 'pcfsoftshadowmap',
            
            // Mock classes and methods to ensure they exist
            GLTFLoader: function() {
                this.load = function(path, onLoad) {
                    console.log("GLTF loading attempted:", path);
                    if (onLoad) setTimeout(() => onLoad({scene: new THREE.Scene()}), 100);
                };
                return this;
            },
            AudioLoader: function() {
                this.load = function(path, onLoad) {
                    console.log("Audio loading attempted:", path);
                    if (onLoad) setTimeout(() => onLoad({}), 100);
                };
                return this;
            }
        };
        
        // Define OrbitControls separately
        THREE.OrbitControls = function(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.enableDamping = false;
            this.dampingFactor = 0;
            this.target = {
                x: 0, y: 0, z: 0,
                set: function(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
            };
            this.maxDistance = 1000;
            this.minDistance = 0;
            this.maxPolarAngle = Math.PI;
            this.update = function() {
                // Mock update logic
                // console.log("OrbitControls updated");
            };
            this.dispose = function() {};
            return this;
        };
        
        console.log("Enhanced THREE environment created");
        
        console.log("Minimal THREE environment created");
    </script>

    <!-- Load the game directly now that THREE is available -->
    <script type="module" src="src/main.js"></script>
</body>
</html>