import{I as v,B as A,G as M,M as I,a as X,V as R,b as V,C as Y}from"./main-xuSD_O1U.js";function y(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?Z(t):t.isInstancedBufferAttribute?new v().copy(t):new A().copy(t)}function Z(t){const r=t.data.array.constructor,i=t.count,o=t.itemSize,a=t.normalized,s=new r(i*o);let e;t.isInstancedInterleavedBufferAttribute?e=new v(s,o,a,t.meshPerAttribute):e=new A(s,o,a);for(let n=0;n<i;n++)e.setX(n,t.getX(n)),o>=2&&e.setY(n,t.getY(n)),o>=3&&e.setZ(n,t.getZ(n)),o>=4&&e.setW(n,t.getW(n));return e}function k(t){if(t.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),t;let r=t.groups;if(r=r.sort((e,n)=>e.materialIndex!==n.materialIndex?e.materialIndex-n.materialIndex:e.start-n.start),t.getIndex()===null){const e=t.getAttribute("position"),n=[];for(let c=0;c<e.count;c+=3)n.push(c,c+1,c+2);t.setIndex(n)}const i=t.getIndex(),o=[];for(let e=0;e<r.length;e++){const n=r[e],c=n.start,u=c+n.count;for(let l=c;l<u;l++)o.push(i.getX(l))}t.dispose(),t.setIndex(o);let a=0;for(let e=0;e<r.length;e++){const n=r[e];n.start=a,a+=n.count}let s=r[0];t.groups=[s];for(let e=1;e<r.length;e++){const n=r[e];s.materialIndex===n.materialIndex?s.count+=n.count:(s=n,t.groups.push(s))}return t}const S=new Y,z=new V;function H(t){const r=new M,i=t.count,o=t.geometry,a=t.material;for(let s=0;s<i;s++){const e=new I(o,a);t.getMatrixAt(s,e.matrix),e.matrix.decompose(e.position,e.quaternion,e.scale),r.add(e)}return r.copy(t),r.updateMatrixWorld(),r}function L(t){if(Array.isArray(t.material)===!1)return console.warn("THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials."),t;const r=new M;r.copy(t);const i=k(t.geometry),o=i.index,a=i.groups,s=Object.keys(i.attributes);for(let e=0;e<a.length;e++){const n=a[e],c=n.start,u=c+n.count,l=new X,B=t.material[n.materialIndex];for(let m=0;m<s.length;m++){const b=s[m],f=i.attributes[b],d=f.itemSize,G=n.count*d,C=f.array.constructor,W=new C(G),g=new A(W,d);for(let w=c,p=0;w<u;w++,p++){const x=o.getX(w);d>=1&&g.setX(p,f.getX(x)),d>=2&&g.setY(p,f.getY(x)),d>=3&&g.setZ(p,f.getZ(x)),d>=4&&g.setW(p,f.getW(x))}l.setAttribute(b,g)}const h=new I(l,B);r.add(h)}return r}function O(t,r){const i=new M;for(let o=0,a=r.length;o<a;o++)i.add(new I(t,r[o]));return i}function P(t,r,i){let o=i;const a=new R;return t.updateWorldMatrix(!0,!0),t.traverseVisible(s=>{const{geometry:e}=s;if(e!==void 0){const{position:n}=e.attributes;if(n!==void 0)for(let c=0,u=n.count;c<u;c++)s.isMesh?s.getVertexPosition(c,a):a.fromBufferAttribute(n,c),s.isSkinnedMesh||a.applyMatrix4(s.matrixWorld),o=r(o,a)}}),o}function U(t,r){const i=y(t.instanceMatrix),o=t.instanceColor?y(t.instanceColor):null,a=new Map;for(const e in t.geometry.attributes){const n=t.geometry.attributes[e];n.isInstancedBufferAttribute&&a.set(n,y(n))}const s=[];for(let e=0;e<t.count;e++)s.push(e);s.sort(r);for(let e=0;e<s.length;e++){const n=s[e];z.fromArray(i.array,n*t.instanceMatrix.itemSize),z.toArray(t.instanceMatrix.array,e*t.instanceMatrix.itemSize),t.instanceColor&&(S.fromArray(o.array,n*t.instanceColor.itemSize),S.toArray(t.instanceColor.array,e*t.instanceColor.itemSize));for(const c in t.geometry.attributes){const u=t.geometry.attributes[c];if(u.isInstancedBufferAttribute){const l=a.get(u);u.setX(e,l.getX(n)),u.itemSize>1&&u.setY(e,l.getY(n)),u.itemSize>2&&u.setZ(e,l.getZ(n)),u.itemSize>3&&u.setW(e,l.getW(n))}}}}function*E(t){yield t;const r=t.children;for(let i=0,o=r.length;i<o;i++)yield*E(r[i])}function*F(t){if(t.visible===!1)return;yield t;const r=t.children;for(let i=0,o=r.length;i<o;i++)yield*F(r[i])}function*N(t){const r=t.parent;r!==null&&(yield r,yield*N(r))}export{H as createMeshesFromInstancedMesh,L as createMeshesFromMultiMaterialMesh,O as createMultiMaterialObject,P as reduceVertices,U as sortInstancedMesh,N as traverseAncestorsGenerator,E as traverseGenerator,F as traverseVisibleGenerator};
